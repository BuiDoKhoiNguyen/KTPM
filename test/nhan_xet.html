<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phân tích hiệu suất: So sánh code cũ và code mới</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #2980b9;
            margin-top: 40px;
            border-left: 4px solid #3498db;
            padding-left: 10px;
        }
        .chart-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 30px;
        }
        .chart-img {
            width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        .analysis {
            background-color: #f1f8ff;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-top: 20px;
            border-radius: 0 8px 8px 0;
        }
        .analysis h3 {
            margin-top: 0;
            color: #2980b9;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
        .conclusion {
            background-color: #e8f4f8;
            border-radius: 8px;
            padding: 20px;
            margin-top: 40px;
            border: 1px solid #3498db;
        }
        .conclusion h2 {
            border-left: none;
            color: #2c3e50;
            text-align: center;
            margin-top: 0;
        }
        .highlight {
            background-color: #ffffcc;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .improvement {
            color: #27ae60;
            font-weight: bold;
        }
        .degradation {
            color: #e74c3c;
            font-weight: bold;
        }
        @media print {
            body {
                background-color: white;
            }
            .chart-container {
                box-shadow: none;
                border: 1px solid #ddd;
                break-inside: avoid;
            }
            h2 {
                break-after: avoid;
            }
            .analysis {
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <h1>Phân tích hiệu suất: So sánh code cũ và code mới</h1>

    <div class="chart-container">
        <h2>1. So sánh tốc độ xử lý yêu cầu (RPS - Requests per second)</h2>
        <img src="chart\rps_comparison.png" alt="So sánh RPS" class="chart-img">
        <div class="analysis">
            <h3>Nhận xét:</h3>
            <ul>
                <li><strong>Thao tác đọc dữ liệu:</strong> Code cũ có khả năng xử lý khoảng <span class="highlight">1822.83 yêu cầu/giây</span>, trong khi code mới chỉ xử lý được <span class="highlight">1252.97 yêu cầu/giây</span>. Điều này cho thấy code cũ nhanh hơn khoảng <span class="degradation">45%</span> trong thao tác đọc.</li>
                <li><strong>Thao tác ghi dữ liệu:</strong> Code cũ có khả năng xử lý <span class="highlight">1112.16 yêu cầu/giây</span>, trong khi code mới chỉ xử lý được <span class="highlight">160.38 yêu cầu/giây</span>. Đây là sự khác biệt rất lớn, với code cũ nhanh hơn khoảng <span class="degradation">7 lần</span>.</li>
                <li><strong>Nguyên nhân có thể:</strong> Code mới có thể đã thêm nhiều tính năng phức tạp hơn như xác thực, kiểm tra dữ liệu, hoặc ghi log chi tiết, dẫn đến giảm tốc độ xử lý nhưng tăng tính ổn định và bảo mật.</li>
            </ul>
        </div>
    </div>

    <div class="chart-container">
        <h2>2. So sánh thời gian phản hồi trung bình</h2>
        <img src="chart\response_time_comparison.png" alt="So sánh thời gian phản hồi" class="chart-img">
        <div class="analysis">
            <h3>Nhận xét:</h3>
            <ul>
                <li><strong>Thao tác đọc dữ liệu:</strong> Code cũ có thời gian phản hồi trung bình là <span class="highlight">54.86ms</span>, trong khi code mới là <span class="highlight">79.81ms</span>. Code mới chậm hơn khoảng <span class="degradation">45%</span>.</li>
                <li><strong>Thao tác ghi dữ liệu:</strong> Code cũ có thời gian phản hồi trung bình là <span class="highlight">8.99ms</span>, trong khi code mới là <span class="highlight">62.35ms</span>. Code mới chậm hơn khoảng <span class="degradation">7 lần</span>.</li>
                <li><strong>Đánh giá tổng thể:</strong> Mặc dù code mới có thời gian phản hồi lâu hơn, nhưng vẫn nằm trong ngưỡng chấp nhận được cho ứng dụng web (dưới 100ms cho thao tác đọc và dưới 1 giây cho thao tác ghi).</li>
            </ul>
        </div>
    </div>

    <div class="chart-container">
        <h2>3. Phân phối thời gian phản hồi cho thao tác đọc</h2>
        <img src="chart\read_percentiles_comparison.png" alt="Phân phối thời gian đọc" class="chart-img">
        <div class="analysis">
            <h3>Nhận xét:</h3>
            <ul>
                <li><strong>Ở phân vị P50 (trung vị):</strong> 50% yêu cầu đọc được xử lý trong <span class="highlight">50ms</span> với code cũ và <span class="highlight">74ms</span> với code mới.</li>
                <li><strong>Ở phân vị P95:</strong> 95% yêu cầu đọc được xử lý trong <span class="highlight">94ms</span> với code cũ và <span class="highlight">119ms</span> với code mới.</li>
                <li><strong>Ở phân vị P100 (thời gian tối đa):</strong> Yêu cầu lâu nhất mất <span class="highlight">156ms</span> với code cũ và <span class="highlight">232ms</span> với code mới.</li>
                <li><strong>Độ ổn định:</strong> Cả hai phiên bản đều có độ ổn định tốt, với sự chênh lệch không quá lớn giữa P50 và P95, cho thấy hầu hết các yêu cầu đều được xử lý với thời gian tương đối đồng đều.</li>
            </ul>
        </div>
    </div>

    <div class="chart-container">
        <h2>4. Phân phối thời gian phản hồi cho thao tác ghi</h2>
        <img src="chart\write_percentiles_comparison.png" alt="Phân phối thời gian ghi" class="chart-img">
        <div class="analysis">
            <h3>Nhận xét:</h3>
            <ul>
                <li><strong>Ở phân vị P50 (trung vị):</strong> 50% yêu cầu ghi được xử lý trong <span class="highlight">8ms</span> với code cũ và <span class="highlight">43ms</span> với code mới.</li>
                <li><strong>Ở phân vị P95:</strong> 95% yêu cầu ghi được xử lý trong <span class="highlight">19ms</span> với code cũ và <span class="highlight">165ms</span> với code mới.</li>
                <li><strong>Ở phân vị P100 (thời gian tối đa):</strong> Yêu cầu lâu nhất mất <span class="highlight">26ms</span> với code cũ và <span class="highlight">1053ms</span> với code mới.</li>
                <li><strong>Độ ổn định:</strong> Code cũ có độ ổn định rất cao với thời gian phản hồi đồng đều. Code mới có sự biến động lớn, đặc biệt ở P99 và P100, cho thấy có một số yêu cầu ghi mất thời gian xử lý rất lâu.</li>
            </ul>
        </div>
    </div>

    <div class="chart-container">
        <h2>5. So sánh hiệu suất Cache Hit vs Cache Miss</h2>
        <img src="chart\cache_performance_comparison.png" alt="So sánh hiệu suất cache" class="chart-img">
        <div class="analysis">
            <h3>Nhận xét:</h3>
            <ul>
                <li><strong>Thời gian trung bình:</strong> Cache Miss mất trung bình <span class="highlight">5.95ms</span>, trong khi Cache Hit chỉ mất <span class="highlight">2.35ms</span>, cải thiện <span class="improvement">60.5%</span>.</li>
                <li><strong>Thời gian trung vị:</strong> Cache Miss có thời gian trung vị là <span class="highlight">6ms</span>, trong khi Cache Hit chỉ có <span class="highlight">2ms</span>, cải thiện <span class="improvement">66.67%</span>.</li>
                <li><strong>Thời gian P95:</strong> 95% Cache Miss được xử lý trong <span class="highlight">10ms</span>, trong khi 95% Cache Hit được xử lý trong <span class="highlight">3ms</span>, cải thiện <span class="improvement">70%</span>.</li>
                <li><strong>Hiệu quả của cache:</strong> Việc sử dụng cache mang lại cải thiện đáng kể về hiệu suất, giảm thời gian xử lý từ 60-70% khi dữ liệu đã được cache.</li>
            </ul>
        </div>
    </div>

    <div class="chart-container">
        <h2>6. Phân phối thời gian xử lý Cache Hit vs Cache Miss</h2>
        <img src="chart\cache_distribution.png" alt="Phân phối thời gian cache" class="chart-img">
        <div class="analysis">
            <h3>Nhận xét:</h3>
            <ul>
                <li><strong>Tập trung của dữ liệu:</strong> Cache Hit có phân phối tập trung hơn, chủ yếu trong khoảng 1-3ms, trong khi Cache Miss có phân phối rộng hơn, từ 2-12ms.</li>
                <li><strong>Độ ổn định:</strong> Cache Hit có độ ổn định cao hơn với ít giá trị ngoại lệ, trong khi Cache Miss có một số giá trị cao bất thường (lên đến 18ms).</li>
                <li><strong>Lợi ích của cache:</strong> Biểu đồ này minh họa rõ ràng lợi ích của việc sử dụng cache, không chỉ giảm thời gian xử lý mà còn tăng tính ổn định và dự đoán được của hệ thống.</li>
            </ul>
        </div>
    </div>

    <div class="chart-container">
        <h2>7. Độ trễ Long Polling</h2>
        <img src="chart\long_polling_latency.png" alt="Độ trễ Long Polling" class="chart-img">
        <div class="analysis">
            <h3>Nhận xét:</h3>
            <ul>
                <li><strong>Độ trễ trung bình:</strong> Long Polling có độ trễ trung bình là <span class="highlight">2155.30ms</span> (khoảng 2.15 giây).</li>
                <li><strong>Độ trễ trung vị:</strong> Giá trị trung vị là <span class="highlight">2145ms</span>, rất gần với giá trị trung bình, cho thấy phân phối tương đối đồng đều.</li>
                <li><strong>Độ trễ tối thiểu và tối đa:</strong> Độ trễ thấp nhất là <span class="highlight">2109ms</span> và cao nhất là <span class="highlight">2306ms</span>, với biên độ dao động khoảng 200ms.</li>
                <li><strong>Đánh giá:</strong> Độ trễ này là điển hình cho cơ chế Long Polling, do client phải chờ server phản hồi hoặc timeout. Đây là một trong những hạn chế của Long Polling so với các giải pháp realtime khác như WebSocket hoặc Server-Sent Events.</li>
            </ul>
        </div>
    </div>

    <div class="conclusion">
        <h2>Kết luận tổng thể</h2>
        <ol>
            <li>
                <strong>Hiệu suất xử lý:</strong>
                <ul>
                    <li>Code cũ có hiệu suất xử lý cao hơn đáng kể, đặc biệt trong thao tác ghi dữ liệu.</li>
                    <li>Code mới có thể đã đánh đổi hiệu suất để đạt được các tính năng khác như bảo mật, tính ổn định, hoặc khả năng mở rộng.</li>
                </ul>
            </li>
            <li>
                <strong>Độ ổn định:</strong>
                <ul>
                    <li>Code cũ có độ ổn định cao với thời gian phản hồi đồng đều.</li>
                    <li>Code mới có một số trường hợp phản hồi rất chậm, đặc biệt trong thao tác ghi, cần được điều tra thêm.</li>
                </ul>
            </li>
            <li>
                <strong>Hiệu quả của cache:</strong>
                <ul>
                    <li>Việc sử dụng cache mang lại cải thiện đáng kể về hiệu suất, giảm thời gian xử lý từ 60-70%.</li>
                    <li>Cache không chỉ giúp giảm thời gian xử lý mà còn tăng tính ổn định của hệ thống.</li>
                </ul>
            </li>
            <li>
                <strong>Độ trễ Long Polling:</strong>
                <ul>
                    <li>Long Polling có độ trễ khoảng 2.15 giây, phù hợp với đặc tính của cơ chế này.</li>
                    <li>Cần cân nhắc sử dụng các giải pháp realtime khác như WebSocket nếu yêu cầu độ trễ thấp hơn.</li>
                </ul>
            </li>
            <li>
                <strong>Đề xuất cải thiện:</strong>
                <ul>
                    <li>Điều tra nguyên nhân gây ra thời gian phản hồi cao trong thao tác ghi của code mới.</li>
                    <li>Tối ưu hóa code mới để cải thiện hiệu suất mà vẫn giữ được các tính năng bổ sung.</li>
                    <li>Mở rộng việc sử dụng cache cho nhiều loại dữ liệu hơn để tận dụng lợi ích của nó.</li>
                    <li>Cân nhắc chuyển từ Long Polling sang WebSocket để giảm độ trễ trong các tương tác realtime.</li>
                </ul>
            </li>
        </ol>
    </div>
</body>
</html>
