<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multi-Instance Benchmark Visualization</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    h1, h2, h3 {
      color: #2c3e50;
    }
    .chart-container {
      position: relative;
      height: 400px;
      margin-bottom: 40px;
    }
    .card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin: 10px 0;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    .card h3 {
      margin-top: 0;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    .stats-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 30px;
    }
    .stat-card {
      flex: 1;
      min-width: 200px;
      background: white;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
    }
    .improvement {
      color: #27ae60;
    }
    .regression {
      color: #e74c3c;
    }
    .neutral {
      color: #3498db;
    }
    .flex-row {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .flex-column {
      flex: 1;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    table, th, td {
      border: 1px solid #ddd;
    }
    th, td {
      text-align: left;
      padding: 12px;
    }
    th {
      background-color: #f2f2f2;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    .loading {
      text-align: center;
      font-size: 24px;
      padding: 40px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Multi-Instance Architecture Benchmark Results</h1>
    <p>Comparison between single-instance KTPM-base and multi-instance KTPM-btl systems under high concurrency</p>
    
    <div id="loading" class="loading">Loading benchmark data...</div>
    
    <div id="results" style="display: none;">
      <div class="stats-container">
        <div class="stat-card">
          <h3>Throughput</h3>
          <div class="stat-value" id="throughput-improvement">-</div>
          <p>Requests processed per second</p>
        </div>
        <div class="stat-card">
          <h3>Response Time</h3>
          <div class="stat-value" id="response-improvement">-</div>
          <p>Average response time</p>
        </div>
        <div class="stat-card">
          <h3>Error Rate</h3>
          <div class="stat-value" id="error-improvement">-</div>
          <p>Failed requests percentage</p>
        </div>
        <div class="stat-card">
          <h3>Scalability Score</h3>
          <div class="stat-value" id="scalability-score">-</div>
          <p>Overall scaling performance</p>
        </div>
      </div>
      
      <div class="flex-row">
        <div class="flex-column">
          <div class="card">
            <h3>Throughput Comparison</h3>
            <div class="chart-container">
              <canvas id="throughputChart"></canvas>
            </div>
          </div>
        </div>
        <div class="flex-column">
          <div class="card">
            <h3>Response Time Comparison</h3>
            <div class="chart-container">
              <canvas id="responseTimeChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      
      <div class="card">
        <h3>Throughput Over Time</h3>
        <div class="chart-container">
          <canvas id="timeSeriesChart"></canvas>
        </div>
      </div>
      
      <div class="flex-row">
        <div class="flex-column">
          <div class="card">
            <h3>Error Distribution</h3>
            <div class="chart-container">
              <canvas id="errorChart"></canvas>
            </div>
          </div>
        </div>
        <div class="flex-column">
          <div class="card">
            <h3>Response Time Distribution</h3>
            <div class="chart-container">
              <canvas id="responseDistributionChart"></canvas>
            </div>
          </div>
        </div>
      </div>
      
      <div class="card">
        <h3>Summary Statistics</h3>
        <table>
          <thead>
            <tr>
              <th>Metric</th>
              <th>KTPM-base (Single Instance)</th>
              <th>KTPM-btl (Multi Instance)</th>
              <th>Improvement</th>
            </tr>
          </thead>
          <tbody id="summaryTable">
            <!-- Data will be filled dynamically -->
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    // Colors for charts
    const colors = {
      base: {
        primary: 'rgba(54, 162, 235, 0.7)',
        border: 'rgba(54, 162, 235, 1)',
        light: 'rgba(54, 162, 235, 0.3)'
      },
      optimized: {
        primary: 'rgba(75, 192, 192, 0.7)',
        border: 'rgba(75, 192, 192, 1)',
        light: 'rgba(75, 192, 192, 0.3)'
      },
      neutral: {
        primary: 'rgba(201, 203, 207, 0.7)',
        border: 'rgba(201, 203, 207, 1)'
      }
    };

    // Function to create and update charts
    async function loadBenchmarkData() {
      try {
        const response = await fetch('multi-instance-benchmark-results.json');
        if (!response.ok) {
          throw new Error('Benchmark data not found. Run the multi-instance benchmark first.');
        }
        
        const data = await response.json();
        document.getElementById('loading').style.display = 'none';
        document.getElementById('results').style.display = 'block';
        
        // Update summary stats
        updateSummaryStats(data);
        
        // Create charts
        createThroughputChart(data);
        createResponseTimeChart(data);
        createTimeSeriesChart(data);
        createErrorChart(data);
        createResponseDistributionChart(data);
        
      } catch (error) {
        document.getElementById('loading').innerHTML = `<p style="color: #e74c3c;">${error.message}</p>`;
      }
    }

    function updateSummaryStats(data) {
      const baseStats = data.summary.base;
      const optimizedStats = data.summary.optimized;
      const comparison = data.comparison;
      
      // Update improvement cards
      const throughputElement = document.getElementById('throughput-improvement');
      throughputElement.textContent = `${optimizedStats.requestsPerSecond.toFixed(2)} rps`;
      throughputElement.className = 'stat-value ' + (comparison.throughputImprovement > 0 ? 'improvement' : 'regression');
      
      const responseElement = document.getElementById('response-improvement');
      responseElement.textContent = `${optimizedStats.avgResponseTime.toFixed(2)} ms`;
      responseElement.className = 'stat-value ' + (comparison.responseTimeImprovement > 0 ? 'improvement' : 'regression');
      
      const errorElement = document.getElementById('error-improvement');
      errorElement.textContent = `${optimizedStats.errorRate.toFixed(2)}%`;
      errorElement.className = 'stat-value ' + (comparison.errorRateImprovement > 0 ? 'improvement' : 'regression');
      
      const scalabilityElement = document.getElementById('scalability-score');
      scalabilityElement.textContent = `${comparison.scalabilityScore.toFixed(1)}/10`;
      
      // Create summary table rows
      const summaryTable = document.getElementById('summaryTable');
      summaryTable.innerHTML = '';
      
      const metricsToShow = [
        { name: 'Total Requests', base: baseStats.totalRequests, optimized: optimizedStats.totalRequests },
        { name: 'Successful Requests', base: baseStats.successfulRequests, optimized: optimizedStats.successfulRequests },
        { name: 'Failed Requests', base: baseStats.failedRequests, optimized: optimizedStats.failedRequests },
        { name: 'Avg Response Time (ms)', base: baseStats.avgResponseTime.toFixed(2), optimized: optimizedStats.avgResponseTime.toFixed(2) },
        { name: 'Min Response Time (ms)', base: baseStats.minResponseTime.toFixed(2), optimized: optimizedStats.minResponseTime.toFixed(2) },
        { name: 'Max Response Time (ms)', base: baseStats.maxResponseTime.toFixed(2), optimized: optimizedStats.maxResponseTime.toFixed(2) },
        { name: 'Requests Per Second', base: baseStats.requestsPerSecond.toFixed(2), optimized: optimizedStats.requestsPerSecond.toFixed(2) },
        { name: 'Error Rate (%)', base: baseStats.errorRate.toFixed(2), optimized: optimizedStats.errorRate.toFixed(2) }
      ];
      
      metricsToShow.forEach(metric => {
        const row = document.createElement('tr');
        
        const nameCell = document.createElement('td');
        nameCell.textContent = metric.name;
        
        const baseCell = document.createElement('td');
        baseCell.textContent = metric.base;
        
        const optimizedCell = document.createElement('td');
        optimizedCell.textContent = metric.optimized;
        
        const improvementCell = document.createElement('td');
        const baseValue = parseFloat(metric.base);
        const optimizedValue = parseFloat(metric.optimized);
        
        if (!isNaN(baseValue) && !isNaN(optimizedValue) && baseValue !== 0) {
          const improvementPercent = ((optimizedValue - baseValue) / baseValue * 100).toFixed(2);
          
          // For metrics where lower is better (response time, error rate)
          const isLowerBetter = metric.name.includes('Response Time') || metric.name.includes('Error Rate') || metric.name.includes('Failed');
          
          const isImprovement = isLowerBetter ? optimizedValue < baseValue : optimizedValue > baseValue;
          
          improvementCell.textContent = `${Math.abs(improvementPercent)}%`;
          
          if (baseValue !== optimizedValue) {
            improvementCell.textContent += isImprovement ? ' better' : ' worse';
            improvementCell.style.color = isImprovement ? '#27ae60' : '#e74c3c';
          } else {
            improvementCell.textContent = 'No change';
            improvementCell.style.color = '#3498db';
          }
        } else {
          improvementCell.textContent = 'N/A';
        }
        
        row.appendChild(nameCell);
        row.appendChild(baseCell);
        row.appendChild(optimizedCell);
        row.appendChild(improvementCell);
        summaryTable.appendChild(row);
      });
    }

    function createThroughputChart(data) {
      const ctx = document.getElementById('throughputChart').getContext('2d');
      
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Single Instance (KTPM-base)', 'Multi Instance (KTPM-btl)'],
          datasets: [{
            label: 'Requests per Second',
            data: [
              data.summary.base.requestsPerSecond,
              data.summary.optimized.requestsPerSecond
            ],
            backgroundColor: [
              colors.base.primary,
              colors.optimized.primary
            ],
            borderColor: [
              colors.base.border,
              colors.optimized.border
            ],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `Throughput: ${data.comparison.throughputImprovement > 0 ? '+' : ''}${data.comparison.throughputImprovement.toFixed(2)}%`
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.raw.toFixed(2)} requests/second`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Requests per Second'
              }
            }
          }
        }
      });
    }

    function createResponseTimeChart(data) {
      const ctx = document.getElementById('responseTimeChart').getContext('2d');
      
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Single Instance (KTPM-base)', 'Multi Instance (KTPM-btl)'],
          datasets: [{
            label: 'Average Response Time (ms)',
            data: [
              data.summary.base.avgResponseTime,
              data.summary.optimized.avgResponseTime
            ],
            backgroundColor: [
              colors.base.primary,
              colors.optimized.primary
            ],
            borderColor: [
              colors.base.border,
              colors.optimized.border
            ],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `Response Time: ${data.comparison.responseTimeImprovement > 0 ? '+' : ''}${data.comparison.responseTimeImprovement.toFixed(2)}%`
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `${context.raw.toFixed(2)} ms`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Response Time (ms)'
              }
            }
          }
        }
      });
    }

    function createTimeSeriesChart(data) {
      const baseTimeSeries = data.detailedMetrics.base.requestsOverTime;
      const optimizedTimeSeries = data.detailedMetrics.optimized.requestsOverTime;
      
      // Group by timestamp and aggregate counts
      const baseByTimestamp = {};
      const optimizedByTimestamp = {};
      
      baseTimeSeries.forEach(item => {
        const timestamp = Math.round(item.timestamp / 1000) * 1000; // Round to nearest second
        baseByTimestamp[timestamp] = (baseByTimestamp[timestamp] || 0) + item.count;
      });
      
      optimizedTimeSeries.forEach(item => {
        const timestamp = Math.round(item.timestamp / 1000) * 1000; // Round to nearest second
        optimizedByTimestamp[timestamp] = (optimizedByTimestamp[timestamp] || 0) + item.count;
      });
      
      // Get all unique timestamps
      const timestamps = [...new Set([
        ...Object.keys(baseByTimestamp),
        ...Object.keys(optimizedByTimestamp)
      ])].map(Number).sort((a, b) => a - b);
      
      const ctx = document.getElementById('timeSeriesChart').getContext('2d');
      
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: timestamps.map(t => `${t/1000}s`),
          datasets: [
            {
              label: 'Single Instance (KTPM-base)',
              data: timestamps.map(t => baseByTimestamp[t] || 0),
              borderColor: colors.base.border,
              backgroundColor: colors.base.light,
              tension: 0.4,
              fill: true
            },
            {
              label: 'Multi Instance (KTPM-btl)',
              data: timestamps.map(t => optimizedByTimestamp[t] || 0),
              borderColor: colors.optimized.border,
              backgroundColor: colors.optimized.light,
              tension: 0.4,
              fill: true
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Request Processing Rate Over Time'
            },
            tooltip: {
              mode: 'index',
              intersect: false
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Test Duration (seconds)'
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Requests Processed'
              }
            }
          }
        }
      });
    }

    function createErrorChart(data) {
      const baseErrorsByType = data.detailedMetrics.base.errorsByType || {};
      const optimizedErrorsByType = data.detailedMetrics.optimized.errorsByType || {};
      
      // Get all unique error types
      const errorTypes = [...new Set([
        ...Object.keys(baseErrorsByType),
        ...Object.keys(optimizedErrorsByType)
      ])];
      
      const ctx = document.getElementById('errorChart').getContext('2d');
      
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: errorTypes.length > 0 ? errorTypes : ['No Errors'],
          datasets: [
            {
              label: 'Single Instance (KTPM-base)',
              data: errorTypes.length > 0 
                ? errorTypes.map(type => baseErrorsByType[type] || 0)
                : [0],
              backgroundColor: colors.base.primary,
              borderColor: colors.base.border,
              borderWidth: 1
            },
            {
              label: 'Multi Instance (KTPM-btl)',
              data: errorTypes.length > 0
                ? errorTypes.map(type => optimizedErrorsByType[type] || 0)
                : [0],
              backgroundColor: colors.optimized.primary,
              borderColor: colors.optimized.border,
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Error Distribution by Type'
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Error Type'
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Number of Errors'
              }
            }
          }
        }
      });
    }

    function createResponseDistributionChart(data) {
      // Create histograms of response times
      const baseResponseTimes = data.detailedMetrics.base.responseTimes || [];
      const optimizedResponseTimes = data.detailedMetrics.optimized.responseTimes || [];
      
      // Create bins for the histogram (0-10ms, 10-20ms, etc.)
      const maxResponseTime = Math.max(
        ...baseResponseTimes,
        ...optimizedResponseTimes,
        100 // Minimum max to ensure we have some bins
      );
      
      const binSize = maxResponseTime > 500 ? 50 : 10; // Adjust bin size based on data range
      const binCount = Math.ceil(maxResponseTime / binSize);
      const bins = Array.from({ length: binCount }, (_, i) => i * binSize);
      
      // Count responses in each bin
      const baseHistogram = new Array(binCount).fill(0);
      const optimizedHistogram = new Array(binCount).fill(0);
      
      baseResponseTimes.forEach(time => {
        const binIndex = Math.floor(time / binSize);
        if (binIndex < binCount) {
          baseHistogram[binIndex]++;
        }
      });
      
      optimizedResponseTimes.forEach(time => {
        const binIndex = Math.floor(time / binSize);
        if (binIndex < binCount) {
          optimizedHistogram[binIndex]++;
        }
      });
      
      // Create bin labels
      const binLabels = bins.map((bin, i) => 
        i === binCount - 1 ? `${bin}+ ms` : `${bin}-${bin + binSize} ms`
      );
      
      const ctx = document.getElementById('responseDistributionChart').getContext('2d');
      
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: binLabels,
          datasets: [
            {
              label: 'Single Instance (KTPM-base)',
              data: baseHistogram,
              backgroundColor: colors.base.primary,
              borderColor: colors.base.border,
              borderWidth: 1
            },
            {
              label: 'Multi Instance (KTPM-btl)',
              data: optimizedHistogram,
              backgroundColor: colors.optimized.primary,
              borderColor: colors.optimized.border,
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Response Time Distribution'
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Response Time'
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Number of Requests'
              }
            }
          }
        }
      });
    }

    // Load data when the page is loaded
    document.addEventListener('DOMContentLoaded', loadBenchmarkData);
  </script>
</body>
</html>